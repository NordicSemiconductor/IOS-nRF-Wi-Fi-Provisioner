// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: result.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

extension Proto {
    // If the compiler emits an error on this type, it is because this file
    // was generated by a version of the `protoc` Swift plug-in that is
    // incompatible with the version of SwiftProtobuf to which you are linking.
    // Please ensure that you are building against the same version of the API
    // that was used to generate this file.
    fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
        struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
        typealias Version = _2
    }
    
    /// Single Wi-Fi scan result.
    struct ScanRecord {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.
        
        var wifi: WifiInfo {
            get {return _wifi ?? WifiInfo()}
            set {_wifi = newValue}
        }
        /// Returns true if `wifi` has been explicitly set.
        var hasWifi: Bool {return self._wifi != nil}
        /// Clears the value of `wifi`. Subsequent reads from it will return its default value.
        mutating func clearWifi() {self._wifi = nil}
        
        var rssi: Int32 {
            get {return _rssi ?? 0}
            set {_rssi = newValue}
        }
        /// Returns true if `rssi` has been explicitly set.
        var hasRssi: Bool {return self._rssi != nil}
        /// Clears the value of `rssi`. Subsequent reads from it will return its default value.
        mutating func clearRssi() {self._rssi = nil}
        
        var unknownFields = SwiftProtobuf.UnknownStorage()
        
        init() {}
        
        fileprivate var _wifi: WifiInfo? = nil
        fileprivate var _rssi: Int32? = nil
    }
    
    ///
    ///This type is returned by the Data Out characteristic using notifications.
    ///Scan records are returned when WiFi scanning is enabled.
    ///WiFi state is notified whenever connection state changes, or during provisioning.
    struct Result {
        // SwiftProtobuf.Message conformance is added in an extension below. See the
        // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
        // methods supported on all messages.
        
        var scanRecord: ScanRecord {
            get {return _scanRecord ?? ScanRecord()}
            set {_scanRecord = newValue}
        }
        /// Returns true if `scanRecord` has been explicitly set.
        var hasScanRecord: Bool {return self._scanRecord != nil}
        /// Clears the value of `scanRecord`. Subsequent reads from it will return its default value.
        mutating func clearScanRecord() {self._scanRecord = nil}
        
        var state: ConnectionState {
            get {return _state ?? .disconnected}
            set {_state = newValue}
        }
        /// Returns true if `state` has been explicitly set.
        var hasState: Bool {return self._state != nil}
        /// Clears the value of `state`. Subsequent reads from it will return its default value.
        mutating func clearState() {self._state = nil}
        
        /// The failure reason is set when the state is CONNECTION_FAILED.
        var reason: ConnectionFailureReason {
            get {return _reason ?? .authError}
            set {_reason = newValue}
        }
        /// Returns true if `reason` has been explicitly set.
        var hasReason: Bool {return self._reason != nil}
        /// Clears the value of `reason`. Subsequent reads from it will return its default value.
        mutating func clearReason() {self._reason = nil}
        
        var unknownFields = SwiftProtobuf.UnknownStorage()
        
        init() {}
        
        fileprivate var _scanRecord: ScanRecord? = nil
        fileprivate var _state: ConnectionState? = nil
        fileprivate var _reason: ConnectionFailureReason? = nil
    }
}

#if swift(>=5.5) && canImport(_Concurrency)
extension Proto.ScanRecord: @unchecked Sendable {}
extension Proto.Result: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Proto.ScanRecord: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "ScanRecord"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "wifi"),
        2: .same(proto: "rssi"),
    ]
    
    public var isInitialized: Bool {
        if let v = self._wifi, !v.isInitialized {return false}
        return true
    }
    
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._wifi) }()
            case 2: try { try decoder.decodeSingularInt32Field(value: &self._rssi) }()
            default: break
            }
        }
    }
    
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._wifi {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._rssi {
            try visitor.visitSingularInt32Field(value: v, fieldNumber: 2)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static func ==(lhs: Proto.ScanRecord, rhs: Proto.ScanRecord) -> Bool {
        if lhs._wifi != rhs._wifi {return false}
        if lhs._rssi != rhs._rssi {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}

extension Proto.Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
    static let protoMessageName: String = "Result"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "scan_record"),
        2: .same(proto: "state"),
        3: .same(proto: "reason"),
    ]
    
    public var isInitialized: Bool {
        if let v = self._scanRecord, !v.isInitialized {return false}
        return true
    }
    
    mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try { try decoder.decodeSingularMessageField(value: &self._scanRecord) }()
            case 2: try { try decoder.decodeSingularEnumField(value: &self._state) }()
            case 3: try { try decoder.decodeSingularEnumField(value: &self._reason) }()
            default: break
            }
        }
    }
    
    func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every if/case branch local when no optimizations
        // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
        // https://github.com/apple/swift-protobuf/issues/1182
        try { if let v = self._scanRecord {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        } }()
        try { if let v = self._state {
            try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
        } }()
        try { if let v = self._reason {
            try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
        } }()
        try unknownFields.traverse(visitor: &visitor)
    }
    
    static func ==(lhs: Proto.Result, rhs: Proto.Result) -> Bool {
        if lhs._scanRecord != rhs._scanRecord {return false}
        if lhs._state != rhs._state {return false}
        if lhs._reason != rhs._reason {return false}
        if lhs.unknownFields != rhs.unknownFields {return false}
        return true
    }
}
